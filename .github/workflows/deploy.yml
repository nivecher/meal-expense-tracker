---
name: Deploy

on:
  workflow_run:
    workflows: [CI]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to deploy to
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: Optional image tag/version to deploy (defaults to latest commit SHA)
        required: false
        type: string

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  APP_NAME: meal-expense-tracker
  PYTHON_VERSION: 3.13
  NODE_VERSION: 22
  AWS_REGION: us-east-1

permissions:
  contents: read
  id-token: write
  actions: read
  checks: write
  statuses: write
  packages: write
  issues: write

jobs:
  validate:
    name: Validate Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment: ${{ steps.determine_env.outputs.environment }}
      image_tag: ${{ steps.determine_tag.outputs.image_tag }}
      version: ${{ steps.determine_tag.outputs.version }}
      tag: ${{ steps.determine_tag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2
        with:
          fetch-depth: 0

      - name: Check CI status
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "‚ùå CI workflow did not succeed, skipping deployment"
              exit 0
            fi
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ CI workflow succeeded, proceeding with deployment"
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Manual trigger via workflow_dispatch"
          fi

      - name: Determine environment
        id: determine_env
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            ENV="dev"
          else
            ENV="${{ github.event.inputs.environment || 'dev' }}"
          fi
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to: ${ENV}"

      - name: Determine image tag and version
        id: determine_tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
            VERSION="${{ github.event.inputs.image_tag }}"
            TAG="${{ github.event.inputs.image_tag }}"
            echo "Using provided tag: ${IMAGE_TAG}"
          else
            git fetch --tags --force || true
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -n "${LATEST_TAG}" ]; then
              VERSION=$(echo "${LATEST_TAG}" | sed 's/^v//')
              TAG="${LATEST_TAG}"
              IMAGE_TAG="${VERSION}"
              echo "Found tag: ${TAG}, version: ${VERSION}"
            else
              IMAGE_TAG="${GITHUB_SHA::7}"
              VERSION="dev"
              TAG="dev"
              echo "No tag found, using SHA: ${IMAGE_TAG}"
            fi
          fi
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

      - name: Add validation summary
        run: |
          echo "## Deployment Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: ${{ steps.determine_env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ steps.determine_tag.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- Image Tag: ${{ steps.determine_tag.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Should Deploy: ${{ steps.check.outputs.should_deploy }}" >> $GITHUB_STEP_SUMMARY

  build:
    name: Build and Push
    needs: [validate]
    if: needs.validate.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.validate.outputs.environment }}
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
      image_tag: ${{ steps.build.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.8.0

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version file
        uses: ./.github/actions/generate-version
        with:
          explicit_version: ${{ needs.validate.outputs.image_tag }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}
          tags: |
            type=raw,value=${{ needs.validate.outputs.image_tag }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,format=short

      - name: Build and push
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          target: lambda
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            ${{ steps.meta.outputs.labels }}
            org.opencontainers.image.version=${{ needs.validate.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
          build-args: |
            BUILDPLATFORM=linux/arm64
            TARGETPLATFORM=linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4.6.0
        with:
          name: sbom-${{ needs.validate.outputs.image_tag }}
          path: |
            sbom.*.json
          retention-days: 30
          if-no-files-found: ignore

      - name: Add build summary
        if: always()
        run: |
          echo "## Docker Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`ghcr.io/${{ github.repository }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Version: \`${{ needs.validate.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Target: \`lambda\`" >> $GITHUB_STEP_SUMMARY
          echo "- Platform(s): \`linux/arm64\`" >> $GITHUB_STEP_SUMMARY
          echo "- Pushed: ‚úÖ" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.build.outputs.digest }}" != "" ]; then
            echo "- Digest: \`${{ steps.build.outputs.digest }}\`" >> $GITHUB_STEP_SUMMARY
          fi

  deploy:
    name: Deploy to ${{ needs.validate.outputs.environment }}
    needs: [validate, build]
    if: needs.validate.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.validate.outputs.environment }}
    permissions:
      id-token: write
      contents: read
      issues: write
    outputs:
      deployment_url: ${{ steps.get_url.outputs.url }}
      deployment_status: ${{ steps.deploy_status.outputs.status }}
      rollback_status: ${{ steps.rollback.outputs.status }}
    env:
      ENVIRONMENT: ${{ needs.validate.outputs.environment }}
      IMAGE_TAG: ${{ needs.validate.outputs.image_tag }}
      VERSION: ${{ needs.validate.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.2

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy-${{ github.run_id }}-${{ env.ENVIRONMENT }}
          role-duration-seconds: 3600

      - name: Get AWS account ID
        id: aws_account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account-id=${AWS_ACCOUNT_ID}" >> $GITHUB_OUTPUT
          echo "‚úÖ Authenticated to AWS account: ${AWS_ACCOUNT_ID}"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: 1.13.5
          terraform_wrapper: false

      - name: Setup Terraform plugin cache
        uses: actions/cache@v4.2.0
        with:
          path: ${{ runner.temp }}/.terraform.d/plugin-cache
          key: terraform-plugins-${{ hashFiles('terraform/**/*.tf') }}
          restore-keys: terraform-plugins-

      - name: Create plugin cache directory
        run: |
          mkdir -p ${{ runner.temp }}/.terraform.d/plugin-cache
          echo "TF_PLUGIN_CACHE_DIR=${{ runner.temp }}/.terraform.d/plugin-cache" >> $GITHUB_ENV
          echo "TF_IN_AUTOMATION=1" >> $GITHUB_ENV

      - name: Generate backend.hcl files
        uses: ./.github/actions/generate-backend-hcl
        with:
          aws_region: ${{ env.AWS_REGION }}

      - name: Terraform init
        run: |
          cd terraform
          terraform init -reconfigure -backend-config=environments/${ENVIRONMENT}/backend.hcl
          echo "‚úÖ Terraform initialized for environment: ${ENVIRONMENT}"
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.8.0

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy Infrastructure (Terraform)
        run: |
          cd terraform
          terraform plan \
            -var-file=environments/${ENVIRONMENT}/terraform.tfvars \
            -var="environment=${ENVIRONMENT}" \
            -out=environments/${ENVIRONMENT}/tfplan \
            -input=false \
            -lock=true
          terraform apply -auto-approve environments/${ENVIRONMENT}/tfplan
          echo "‚úÖ Infrastructure deployed"

      - name: Get ECR repository and current Lambda config
        id: lambda_info
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/meal-expense-tracker-${ENVIRONMENT}-lambda"
          FUNCTION_NAME="meal-expense-tracker-${ENVIRONMENT}"
          
          echo "repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          echo "function_name=${FUNCTION_NAME}" >> $GITHUB_OUTPUT
          echo "ECR Repository: ${ECR_REPO}"
          
          # Get current Lambda config for rollback
          CURRENT_CONFIG=$(aws lambda get-function \
            --function-name ${FUNCTION_NAME} \
            --region ${AWS_REGION} 2>/dev/null || echo "{}")
          
          if [ "$CURRENT_CONFIG" != "{}" ]; then
            CURRENT_IMAGE_URI=$(echo "$CURRENT_CONFIG" | jq -r '.Code.ImageUri // empty')
            echo "current_image_uri=${CURRENT_IMAGE_URI}" >> $GITHUB_OUTPUT
            echo "Current Lambda image: ${CURRENT_IMAGE_URI}"
          else
            echo "current_image_uri=" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Function not found or first deployment"
          fi

      - name: Login to ECR and push image
        run: |
          ECR_REPO="${{ steps.lambda_info.outputs.repository }}"
          
          aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin ${ECR_REPO}
          
          docker pull --platform linux/arm64 ghcr.io/${{ github.repository }}:${IMAGE_TAG} || \
          docker pull --platform linux/arm64 ghcr.io/${{ github.repository }}:${GITHUB_SHA::7} || {
            echo "‚ùå Could not pull image from GHCR"
            exit 1
          }
          
          docker tag ghcr.io/${{ github.repository }}:${IMAGE_TAG} ${ECR_REPO}:${IMAGE_TAG} || \
          docker tag ghcr.io/${{ github.repository }}:${GITHUB_SHA::7} ${ECR_REPO}:${IMAGE_TAG}
          docker tag ${ECR_REPO}:${IMAGE_TAG} ${ECR_REPO}:latest
          
          docker push ${ECR_REPO}:${IMAGE_TAG}
          docker push ${ECR_REPO}:latest
          echo "‚úÖ Images pushed to ECR"

      - name: Update Lambda function
        id: update_lambda
        run: |
          FUNCTION_NAME="${{ steps.lambda_info.outputs.function_name }}"
          ECR_REPO="${{ steps.lambda_info.outputs.repository }}"
          
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${ECR_REPO}:latest \
            --region ${AWS_REGION}
          
          aws lambda wait function-updated \
            --function-name ${FUNCTION_NAME} \
            --region ${AWS_REGION}
          
          echo "‚úÖ Lambda function updated"

      - name: Sync static files to S3
        run: |
          if [ -f scripts/sync_static_to_s3.sh ]; then
            chmod +x scripts/sync_static_to_s3.sh
            ./scripts/sync_static_to_s3.sh || echo "‚ö†Ô∏è  Static file sync failed, continuing..."
          fi

      - name: Get deployment URL
        id: get_url
        run: |
          API_URL=$(aws apigatewayv2 get-apis \
            --query "Items[?contains(Name, 'meal-expense-tracker-${ENVIRONMENT}')].ApiEndpoint" \
            --output text \
            --region ${AWS_REGION} 2>/dev/null || echo "")
          
          if [ -z "$API_URL" ]; then
            case "${ENVIRONMENT}" in
              dev) API_URL="https://meals.dev.nivecher.com" ;;
              staging) API_URL="https://meals.staging.nivecher.com" ;;
              prod) API_URL="https://meals.nivecher.com" ;;
            esac
          fi
          
          echo "url=${API_URL}" >> $GITHUB_OUTPUT
          echo "Deployment URL: ${API_URL}"

      - name: Verify Deployment (Health Check)
        id: verify
        run: |
          DEPLOYMENT_URL="${{ steps.get_url.outputs.url }}"
          echo "Verifying deployment at: ${DEPLOYMENT_URL}"
          
          MAX_ATTEMPTS=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -f -s "${DEPLOYMENT_URL}/health" > /dev/null; then
              echo "‚úÖ Health check passed on attempt ${i}"
              echo "deployment_healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            WAIT_TIME=$((2 ** (i - 1)))
            [ $WAIT_TIME -gt 60 ] && WAIT_TIME=60
            
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Attempt ${i}/${MAX_ATTEMPTS} failed, retrying in ${WAIT_TIME}s..."
              sleep $WAIT_TIME
            fi
          done
          
          echo "‚ùå Health check failed after ${MAX_ATTEMPTS} attempts"
          echo "deployment_healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Rollback on failure
        if: failure() && steps.lambda_info.outputs.current_image_uri != ''
        id: rollback
        run: |
          FUNCTION_NAME="${{ steps.lambda_info.outputs.function_name }}"
          PREVIOUS_IMAGE_URI="${{ steps.lambda_info.outputs.current_image_uri }}"
          
          echo "‚ùå Deployment failed, initiating rollback to: ${PREVIOUS_IMAGE_URI}"
          
          if aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${PREVIOUS_IMAGE_URI} \
            --region ${AWS_REGION}; then
            
            aws lambda wait function-updated \
              --function-name ${FUNCTION_NAME} \
              --region ${AWS_REGION}
            
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Rolled back to previous version"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Failed to rollback Lambda function"
            exit 1
          fi

      - name: Set deployment status
        id: deploy_status
        if: always()
        run: |
          if [ "${{ steps.verify.outcome }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          elif [ "${{ steps.rollback.outcome }}" = "success" ]; then
            echo "status=rolled_back" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub issue on failure
        if: failure() && steps.verify.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          VERSION: ${{ env.VERSION }}
          ROLLBACK_STATUS: ${{ steps.rollback.outputs.status }}
        with:
          script: |
            const repo = context.repo;
            const workflowRunId = context.runId;
            const workflowUrl = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${workflowRunId}`;
            const environment = process.env.ENVIRONMENT;
            const version = process.env.VERSION;
            const rollbackStatus = process.env.ROLLBACK_STATUS || '';
            const rollbackSuccess = rollbackStatus === 'success';
            
            const title = `üö® Deployment Failed - ${environment} (${version})`;
            const body = `## Deployment Verification Failed
              
            Deployment to **${environment}** environment failed health checks.
            
            - **Environment:** ${environment}
            - **Version:** ${version}
            - **Commit:** ${context.sha.slice(0, 7)}
            - **Workflow:** [View Run](${workflowUrl})
            - **Rollback:** ${rollbackSuccess ? '‚úÖ Successful' : '‚ùå Failed'}
            
            ${rollbackSuccess ? '‚ö†Ô∏è System rolled back to previous version.' : 'üö® Manual intervention required.'}
            
            ### Next Steps
            1. Review workflow logs: ${workflowUrl}
            2. Check application logs in CloudWatch
            3. Verify infrastructure status
            4. ${rollbackSuccess ? 'Investigate deployment failure' : 'Manually rollback if needed'}`;
            
            await github.rest.issues.create({
              ...repo,
              title: title,
              body: body,
              labels: ['deployment', 'rollback', 'urgent', environment],
            });

      - name: Add deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "- Image Tag: ${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment URL: ${{ steps.get_url.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "- Status: ${{ steps.deploy_status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.verify.outcome }}" = "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Deployment successful and verified" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.rollback.outcome }}" = "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ö†Ô∏è Deployment failed but rollback successful" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚ùå Deployment failed" >> $GITHUB_STEP_SUMMARY
          fi

  notify:
    name: Notify Deployment Status
    needs: [validate, deploy]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      checks: write
    steps:
      - name: Send Deployment Status
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ needs.validate.outputs.environment }}
          VERSION: ${{ needs.validate.outputs.version }}
          TAG: ${{ needs.validate.outputs.tag }}
          STATUS: ${{ needs.deploy.outputs.deployment_status }}
          ROLLBACK_STATUS: ${{ needs.deploy.outputs.rollback_status }}
        with:
          script: |
            const { ENVIRONMENT, VERSION, TAG, STATUS, ROLLBACK_STATUS } = process.env;
            const repo = context.repo;
            const workflowRunId = context.runId;
            const workflowUrl = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${workflowRunId}`;
            
            const conclusion = STATUS === 'success' ? 'success' : 
                              STATUS === 'rolled_back' ? 'neutral' : 'failure';
            
            const emoji = STATUS === 'success' ? '‚úÖ' : 
                         STATUS === 'rolled_back' ? '‚ö†Ô∏è' : '‚ùå';
            
            await github.rest.checks.create({
              ...repo,
              name: `Deployment to ${ENVIRONMENT}`,
              head_sha: context.sha,
              status: 'completed',
              conclusion: conclusion,
              details_url: workflowUrl,
              output: {
                title: `Deployment ${STATUS} - Version ${VERSION}`,
                summary: `${emoji} Deployment to ${ENVIRONMENT} ${STATUS} - Version ${VERSION}`,
                text: `Workflow: ${workflowUrl}\nVersion: ${VERSION}\nTag: ${TAG}\nRollback: ${ROLLBACK_STATUS || 'N/A'}`,
              },
            });
