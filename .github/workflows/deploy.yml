---
name: Deploy

on:
  workflow_run:
    workflows: [CI]
    types:
      - completed
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to deploy to
        required: true
        default: dev
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: Optional image tag/version to deploy (defaults to latest commit SHA)
        required: false
        type: string

# Concurrency: One deployment per environment at a time
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

env:
  APP_NAME: meal-expense-tracker
  PYTHON_VERSION: 3.13
  NODE_VERSION: 22
  AWS_REGION: us-east-1

permissions:
  contents: read
  id-token: write
  actions: read
  checks: write
  statuses: write
  packages: write
  issues: write

jobs:
  # Validate deployment conditions and determine deployment parameters
  validate:
    name: Validate Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment: ${{ steps.determine_env.outputs.environment }}
      image_tag: ${{ steps.determine_tag.outputs.image_tag }}
      version: ${{ steps.determine_tag.outputs.version }}
      tag: ${{ steps.determine_tag.outputs.tag }}
    steps:
      - name: Check CI status
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "‚ùå CI workflow did not succeed, skipping deployment"
              exit 0
            fi
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ CI workflow succeeded, proceeding with deployment"
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Manual trigger via workflow_dispatch"
          fi

      - name: Determine environment
        id: determine_env
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            ENV="dev"
          else
            ENV="${{ github.event.inputs.environment || 'dev' }}"
          fi
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "Deploying to: ${ENV}"

      - name: Determine image tag and version
        id: determine_tag
        run: |
          # Check if manual tag provided
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
            VERSION="${{ github.event.inputs.image_tag }}"
            TAG="${{ github.event.inputs.image_tag }}"
            echo "Using provided tag: ${IMAGE_TAG}"
          else
            # Auto-determine from git tags or use SHA
            git fetch --tags --force || true
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -n "${LATEST_TAG}" ]; then
              VERSION=$(echo "${LATEST_TAG}" | sed 's/^v//')
              TAG="${LATEST_TAG}"
              IMAGE_TAG="${VERSION}"
              echo "Found tag: ${TAG}, version: ${VERSION}"
            else
              # Use commit SHA as fallback
              IMAGE_TAG="${GITHUB_SHA::7}"
              VERSION="dev"
              TAG="dev"
              echo "No tag found, using SHA: ${IMAGE_TAG}"
            fi
          fi
          
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

  # Build and push Docker image to GHCR
  build:
    name: Build and Push
    needs: [validate]
    if: needs.validate.outputs.should_deploy == 'true'
    uses: ./.github/workflows/docker-build.yml
    with:
      image_name: ${{ github.repository }}
      version: ${{ needs.validate.outputs.image_tag }}
      push: true
      registry: ghcr.io
      target: lambda
      platforms: linux/arm64
      fetch_depth: 0
      generate_version: true
      custom_tags: |
        type=raw,value=${{ needs.validate.outputs.image_tag }}
        type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}
        type=sha,format=short
      custom_labels: |
        org.opencontainers.image.version=${{ needs.validate.outputs.version }}
        org.opencontainers.image.revision=${{ github.sha }}
      build_args: |
        BUILDPLATFORM=linux/arm64
        TARGETPLATFORM=linux/arm64
      environment: ${{ needs.validate.outputs.environment }}
    secrets: inherit

  # Unified deployment job for all environments
  deploy:
    name: Deploy to ${{ needs.validate.outputs.environment }}
    needs: [validate, build]
    if: needs.validate.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.validate.outputs.environment }}
    permissions:
      id-token: write
      contents: read
      issues: write
    outputs:
      deployment_url: ${{ steps.get_url.outputs.url }}
      deployment_status: ${{ steps.deploy_status.outputs.status }}
      rollback_status: ${{ steps.rollback.outputs.status }}
    env:
      ENVIRONMENT: ${{ needs.validate.outputs.environment }}
      IMAGE_TAG: ${{ needs.validate.outputs.image_tag }}
      VERSION: ${{ needs.validate.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}
          role-duration-seconds: 3600

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.5
          terraform_wrapper: false

      - name: Setup Terraform plugin cache
        uses: actions/cache@v4
        with:
          path: ${{ runner.temp }}/.terraform.d/plugin-cache
          key: terraform-plugins-${{ hashFiles('terraform/**/*.tf') }}
          restore-keys: |
            terraform-plugins-

      - name: Generate backend.hcl files from templates
        uses: ./.github/actions/generate-backend-hcl
        with:
          aws_region: ${{ env.AWS_REGION }}

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Deploy Infrastructure (Terraform)
        env:
          TF_PLUGIN_CACHE_DIR: ${{ runner.temp }}/.terraform.d/plugin-cache
          TF_IN_AUTOMATION: 1
        run: |
          cd terraform
          terraform init -reconfigure -backend-config=environments/${ENVIRONMENT}/backend.hcl
          terraform plan \
            -var-file=environments/${ENVIRONMENT}/terraform.tfvars \
            -var="environment=${ENVIRONMENT}" \
            -out=environments/${ENVIRONMENT}/tfplan \
            -input=false \
            -lock=true
          terraform apply -auto-approve environments/${ENVIRONMENT}/tfplan

      - name: Get ECR repository URI
        id: ecr_repo
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPO="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/meal-expense-tracker-${ENVIRONMENT}-lambda"
          echo "repository=${ECR_REPO}" >> $GITHUB_OUTPUT
          echo "ECR Repository: ${ECR_REPO}"

      - name: Get current Lambda function configuration
        id: current_lambda
        run: |
          FUNCTION_NAME="meal-expense-tracker-${ENVIRONMENT}"
          
          # Get current function configuration for rollback
          CURRENT_CONFIG=$(aws lambda get-function \
            --function-name ${FUNCTION_NAME} \
            --region ${AWS_REGION} 2>/dev/null || echo "{}")
          
          if [ "$CURRENT_CONFIG" != "{}" ]; then
            CURRENT_IMAGE_URI=$(echo "$CURRENT_CONFIG" | jq -r '.Code.ImageUri // empty')
            CURRENT_VERSION=$(echo "$CURRENT_CONFIG" | jq -r '.Configuration.Version // empty')
            echo "current_image_uri=${CURRENT_IMAGE_URI}" >> $GITHUB_OUTPUT
            echo "current_version=${CURRENT_VERSION}" >> $GITHUB_OUTPUT
            echo "Current Lambda image: ${CURRENT_IMAGE_URI}, version: ${CURRENT_VERSION}"
          else
            echo "current_image_uri=" >> $GITHUB_OUTPUT
            echo "current_version=" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Function not found or first deployment"
          fi

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${AWS_REGION} | \
            docker login --username AWS --password-stdin ${{ steps.ecr_repo.outputs.repository }}

      - name: Tag and push Docker image to ECR
        run: |
          ECR_REPO="${{ steps.ecr_repo.outputs.repository }}"
          IMAGE_TAG="${IMAGE_TAG}"
          
          # Pull from GHCR with platform specification (arm64 for Lambda)
          docker pull --platform linux/arm64 ghcr.io/${{ github.repository }}:${IMAGE_TAG} || \
          docker pull --platform linux/arm64 ghcr.io/${{ github.repository }}:${GITHUB_SHA::7} || {
            echo "‚ùå Could not pull image from GHCR"
            exit 1
          }
          
          # Tag and push to ECR
          docker tag ghcr.io/${{ github.repository }}:${IMAGE_TAG} ${ECR_REPO}:${IMAGE_TAG} || \
          docker tag ghcr.io/${{ github.repository }}:${GITHUB_SHA::7} ${ECR_REPO}:${IMAGE_TAG}
          docker tag ${ECR_REPO}:${IMAGE_TAG} ${ECR_REPO}:latest
          
          docker push ${ECR_REPO}:${IMAGE_TAG}
          docker push ${ECR_REPO}:latest

      - name: Update Lambda function
        id: update_lambda
        run: |
          FUNCTION_NAME="meal-expense-tracker-${ENVIRONMENT}"
          ECR_REPO="${{ steps.ecr_repo.outputs.repository }}"
          
          aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${ECR_REPO}:latest \
            --region ${AWS_REGION}
          
          aws lambda wait function-updated \
            --function-name ${FUNCTION_NAME} \
            --region ${AWS_REGION}
          
          echo "‚úÖ Lambda function updated"

      - name: Sync static files to S3
        run: |
          chmod +x scripts/sync_static_to_s3.sh
          ./scripts/sync_static_to_s3.sh || echo "‚ö†Ô∏è  Static file sync failed, continuing..."

      - name: Get deployment URL
        id: get_url
        run: |
          # Try API Gateway first
          API_URL=$(aws apigatewayv2 get-apis \
            --query "Items[?contains(Name, 'meal-expense-tracker-${ENVIRONMENT}')].ApiEndpoint" \
            --output text \
            --region ${AWS_REGION} 2>/dev/null || echo "")
          
          # Fallback to environment-specific defaults
          if [ -z "$API_URL" ]; then
            case "${ENVIRONMENT}" in
              dev)
                API_URL="https://meals.dev.nivecher.com"
                ;;
              staging)
                API_URL="https://meals.staging.nivecher.com"
                ;;
              prod)
                API_URL="https://meals.nivecher.com"
                ;;
            esac
          fi
          
          echo "url=${API_URL}" >> $GITHUB_OUTPUT
          echo "Deployment URL: ${API_URL}"

      - name: Verify Deployment (Health Check with Exponential Backoff)
        id: verify
        run: |
          DEPLOYMENT_URL="${{ steps.get_url.outputs.url }}"
          echo "Verifying deployment at: ${DEPLOYMENT_URL}"
          
          MAX_ATTEMPTS=15
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -f -s "${DEPLOYMENT_URL}/health" > /dev/null; then
              echo "‚úÖ Health check passed on attempt ${i}"
              echo "deployment_healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # Exponential backoff: 2^(i-1) seconds, capped at 60s
            WAIT_TIME=$((2 ** (i - 1)))
            if [ $WAIT_TIME -gt 60 ]; then
              WAIT_TIME=60
            fi
            
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Attempt ${i}/${MAX_ATTEMPTS} failed, retrying in ${WAIT_TIME} seconds..."
              sleep $WAIT_TIME
            fi
          done
          
          echo "‚ùå Health check failed after ${MAX_ATTEMPTS} attempts"
          echo "deployment_healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Get previous Lambda version for rollback
        if: steps.verify.outcome == 'failure'
        id: previous_version
        run: |
          FUNCTION_NAME="meal-expense-tracker-${ENVIRONMENT}"
          
          # Try to get previous version from Lambda version history
          PREVIOUS_VERSION=$(aws lambda list-versions-by-function \
            --function-name ${FUNCTION_NAME} \
            --region ${AWS_REGION} \
            --query 'Versions[-2].Version' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_VERSION" ] && [ "$PREVIOUS_VERSION" != "\$LATEST" ]; then
            # Get image URI from previous version
            PREVIOUS_CONFIG=$(aws lambda get-function \
              --function-name ${FUNCTION_NAME} \
              --qualifier ${PREVIOUS_VERSION} \
              --region ${AWS_REGION} 2>/dev/null || echo "{}")
            
            PREVIOUS_IMAGE_URI=$(echo "$PREVIOUS_CONFIG" | jq -r '.Code.ImageUri // empty')
            
            if [ -n "$PREVIOUS_IMAGE_URI" ]; then
              echo "previous_image_uri=${PREVIOUS_IMAGE_URI}" >> $GITHUB_OUTPUT
              echo "previous_version=${PREVIOUS_VERSION}" >> $GITHUB_OUTPUT
              echo "Found previous version: ${PREVIOUS_VERSION}, image: ${PREVIOUS_IMAGE_URI}"
            else
              # Fallback: use current_image_uri if available
              if [ -n "${{ steps.current_lambda.outputs.current_image_uri }}" ]; then
                echo "previous_image_uri=${{ steps.current_lambda.outputs.current_image_uri }}" >> $GITHUB_OUTPUT
                echo "previous_version=${{ steps.current_lambda.outputs.current_version }}" >> $GITHUB_OUTPUT
                echo "Using current image as fallback: ${{ steps.current_lambda.outputs.current_image_uri }}"
              else
                echo "previous_image_uri=" >> $GITHUB_OUTPUT
                echo "previous_version=" >> $GITHUB_OUTPUT
                echo "‚ö†Ô∏è  Could not determine previous version"
              fi
            fi
          else
            # Fallback: use current_image_uri if available
            if [ -n "${{ steps.current_lambda.outputs.current_image_uri }}" ]; then
              echo "previous_image_uri=${{ steps.current_lambda.outputs.current_image_uri }}" >> $GITHUB_OUTPUT
              echo "previous_version=${{ steps.current_lambda.outputs.current_version }}" >> $GITHUB_OUTPUT
              echo "Using current image as fallback: ${{ steps.current_lambda.outputs.current_image_uri }}"
            else
              echo "previous_image_uri=" >> $GITHUB_OUTPUT
              echo "previous_version=" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Could not determine previous version"
            fi
          fi

      - name: Rollback on failure
        if: steps.verify.outcome == 'failure' && steps.previous_version.outputs.previous_image_uri != ''
        id: rollback
        run: |
          FUNCTION_NAME="meal-expense-tracker-${ENVIRONMENT}"
          PREVIOUS_IMAGE_URI="${{ steps.previous_version.outputs.previous_image_uri }}"
          
          echo "‚ùå Deployment verification failed, initiating rollback..."
          echo "Rolling back to: ${PREVIOUS_IMAGE_URI}"
          
          # Update Lambda to previous version
          if aws lambda update-function-code \
            --function-name ${FUNCTION_NAME} \
            --image-uri ${PREVIOUS_IMAGE_URI} \
            --region ${AWS_REGION}; then
            
            aws lambda wait function-updated \
              --function-name ${FUNCTION_NAME} \
              --region ${AWS_REGION}
            
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Rolled back to previous version"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Failed to rollback Lambda function"
            exit 1
          fi

      - name: Verify rollback
        if: steps.verify.outcome == 'failure' && steps.rollback.outputs.status == 'success'
        run: |
          DEPLOYMENT_URL="${{ steps.get_url.outputs.url }}"
          echo "Verifying rollback at: ${DEPLOYMENT_URL}"
          
          # Wait for Lambda to update
          sleep 30
          
          # Health check rollback with exponential backoff
          MAX_ATTEMPTS=5
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -f -s "${DEPLOYMENT_URL}/health" > /dev/null; then
              echo "‚úÖ Rollback verified - health check passed"
              exit 0
            fi
            
            WAIT_TIME=$((2 ** (i - 1)))
            if [ $WAIT_TIME -gt 30 ]; then
              WAIT_TIME=30
            fi
            
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Rollback verification attempt ${i}/${MAX_ATTEMPTS} failed, retrying in ${WAIT_TIME} seconds..."
              sleep $WAIT_TIME
            fi
          done
          
          echo "‚ùå Rollback verification failed"
          exit 1

      - name: Set deployment status
        id: deploy_status
        if: always()
        run: |
          if [ "${{ steps.verify.outcome }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          elif [ "${{ steps.rollback.outcome }}" = "success" ]; then
            echo "status=rolled_back" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub issue on failure
        if: steps.verify.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ env.ENVIRONMENT }}
          VERSION: ${{ env.VERSION }}
          ROLLBACK_STATUS: ${{ steps.rollback.outputs.status }}
        with:
          script: |
            const repo = context.repo;
            const workflowRunId = context.runId;
            const workflowUrl = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${workflowRunId}`;
            const environment = process.env.ENVIRONMENT;
            const version = process.env.VERSION;
            const rollbackStatus = process.env.ROLLBACK_STATUS || '';
            const rollbackSuccess = rollbackStatus === 'success';
            
            const title = `üö® Deployment Failed - ${environment} (${version})`;
            const body = `## Deployment Verification Failed
              
            Deployment to **${environment}** environment failed health checks.
            
            - **Environment:** ${environment}
            - **Version:** ${version}
            - **Commit:** ${context.sha.slice(0, 7)}
            - **Workflow:** [View Run](${workflowUrl})
            - **Rollback:** ${rollbackSuccess ? '‚úÖ Successful' : '‚ùå Failed'}
            
            ${rollbackSuccess ? '‚ö†Ô∏è System has been rolled back to previous version. Please investigate the deployment issue.' : 'üö® Manual intervention required - rollback failed.'}
            
            ### Next Steps
            1. Review the workflow logs: ${workflowUrl}
            2. Check application logs in CloudWatch
            3. Verify infrastructure status
            4. ${rollbackSuccess ? 'Investigate why the new version failed' : 'Manually rollback if needed'}`;
            
            await github.rest.issues.create({
              ...repo,
              title: title,
              body: body,
              labels: ['deployment', 'rollback', 'urgent', environment]
            });

  # Notify deployment status
  notify:
    name: Notify Deployment Status
    needs: [validate, deploy]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Send Deployment Status
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ needs.validate.outputs.environment }}
          VERSION: ${{ needs.validate.outputs.version }}
          TAG: ${{ needs.validate.outputs.tag }}
          STATUS: ${{ needs.deploy.outputs.deployment_status }}
          ROLLBACK_STATUS: ${{ needs.deploy.outputs.rollback_status }}
        with:
          script: |
            const { ENVIRONMENT, VERSION, TAG, STATUS, ROLLBACK_STATUS } = process.env;
            const repo = context.repo;
            const workflowRunId = context.runId;
            const workflowUrl = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${workflowRunId}`;
            
            const conclusion = STATUS === 'success' ? 'success' : 
                              STATUS === 'rolled_back' ? 'neutral' : 'failure';
            
            const emoji = STATUS === 'success' ? '‚úÖ' : 
                         STATUS === 'rolled_back' ? '‚ö†Ô∏è' : '‚ùå';
            
            await github.rest.checks.create({
              ...repo,
              name: `Deployment to ${ENVIRONMENT}`,
              head_sha: context.sha,
              status: 'completed',
              conclusion: conclusion,
              details_url: workflowUrl,
              output: {
                title: `Deployment ${STATUS} - Version ${VERSION}`,
                summary: `${emoji} Deployment to ${ENVIRONMENT} ${STATUS} - Version ${VERSION}`,
                text: `Workflow run: ${workflowUrl}\nVersion: ${VERSION}\nTag: ${TAG}\nRollback: ${ROLLBACK_STATUS || 'N/A'}`
              }
            });
